/**
 * Modal sandbox API client.
 *
 * Provides methods to interact with Modal sandboxes from the control plane.
 * All requests are authenticated using HMAC-signed tokens.
 */

import { generateInternalToken } from "@open-inspect/shared";
import { createLogger } from "../logger";
import type { CorrelationContext } from "./provider";

const log = createLogger("modal-client");

// Modal app name
const MODAL_APP_NAME = "open-inspect";

/**
 * Construct the Modal base URL from workspace name.
 * Modal endpoint URLs follow the pattern: https://{workspace}--{app-name}
 */
function getModalBaseUrl(workspace: string): string {
  return `https://${workspace}--${MODAL_APP_NAME}`;
}

export interface CreateSandboxRequest {
  sessionId: string;
  sandboxId?: string; // Expected sandbox ID (generated by control plane)
  repoOwner: string;
  repoName: string;
  controlPlaneUrl: string;
  sandboxAuthToken: string;
  snapshotId?: string;
  opencodeSessionId?: string;
  provider?: string;
  model?: string;
  userEnvVars?: Record<string, string>;
  repoImageId?: string | null;
  repoImageSha?: string | null;
  timeoutSeconds?: number;
  branch?: string;
}

export interface CreateSandboxResponse {
  sandboxId: string;
  modalObjectId?: string; // Modal's internal object ID for snapshot API
  status: string;
  createdAt: number;
}

export interface RestoreSandboxRequest {
  snapshotImageId: string;
  sessionId: string;
  sandboxId: string;
  sandboxAuthToken: string;
  controlPlaneUrl: string;
  repoOwner: string;
  repoName: string;
  provider: string;
  model: string;
  userEnvVars?: Record<string, string>;
  timeoutSeconds?: number;
  branch?: string;
}

export interface RestoreSandboxResponse {
  success: boolean;
  sandboxId?: string;
  modalObjectId?: string;
  error?: string;
}

export interface SnapshotSandboxRequest {
  providerObjectId: string;
  sessionId: string;
  reason: string;
}

export interface SnapshotSandboxResponse {
  success: boolean;
  imageId?: string;
  error?: string;
}

export interface WarmSandboxRequest {
  repoOwner: string;
  repoName: string;
  controlPlaneUrl?: string;
}

export interface WarmSandboxResponse {
  sandboxId: string;
  status: string;
}

export interface BuildRepoImageRequest {
  repoOwner: string;
  repoName: string;
  defaultBranch?: string;
  buildId: string;
  callbackUrl: string;
}

export interface BuildRepoImageResponse {
  buildId: string;
  status: string;
}

export interface DeleteProviderImageRequest {
  providerImageId: string;
}

export interface DeleteProviderImageResponse {
  providerImageId: string;
  deleted: boolean;
}

export interface SnapshotInfo {
  id: string;
  repoOwner: string;
  repoName: string;
  baseSha: string;
  status: string;
  createdAt: string;
  expiresAt?: string;
}

interface ModalApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

/**
 * Error thrown by ModalClient when the Modal API returns a non-OK HTTP status.
 * Carries the numeric status code so callers can classify without string parsing.
 */
export class ModalApiError extends Error {
  constructor(
    message: string,
    public readonly status: number
  ) {
    super(message);
    this.name = "ModalApiError";
  }
}

/**
 * Modal sandbox API client.
 *
 * Requires MODAL_API_SECRET for authentication and MODAL_WORKSPACE for URL construction.
 */
export class ModalClient {
  private createSandboxUrl: string;
  private warmSandboxUrl: string;
  private healthUrl: string;
  private snapshotUrl: string;
  private snapshotSandboxUrl: string;
  private restoreSandboxUrl: string;
  private buildRepoImageUrl: string;
  private deleteProviderImageUrl: string;
  private secret: string;

  constructor(secret: string, workspace: string) {
    if (!secret) {
      throw new Error("ModalClient requires MODAL_API_SECRET for authentication");
    }
    if (!workspace) {
      throw new Error("ModalClient requires MODAL_WORKSPACE for URL construction");
    }
    this.secret = secret;
    const baseUrl = getModalBaseUrl(workspace);
    this.createSandboxUrl = `${baseUrl}-api-create-sandbox.modal.run`;
    this.warmSandboxUrl = `${baseUrl}-api-warm-sandbox.modal.run`;
    this.healthUrl = `${baseUrl}-api-health.modal.run`;
    this.snapshotUrl = `${baseUrl}-api-snapshot.modal.run`;
    this.snapshotSandboxUrl = `${baseUrl}-api-snapshot-sandbox.modal.run`;
    this.restoreSandboxUrl = `${baseUrl}-api-restore-sandbox.modal.run`;
    this.buildRepoImageUrl = `${baseUrl}-api-build-repo-image.modal.run`;
    this.deleteProviderImageUrl = `${baseUrl}-api-delete-provider-image.modal.run`;
  }

  /**
   * Generate authentication headers for POST/PUT requests (includes Content-Type).
   */
  private async getPostHeaders(correlation?: CorrelationContext): Promise<Record<string, string>> {
    const token = await generateInternalToken(this.secret);
    const headers: Record<string, string> = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    };
    if (correlation?.trace_id) headers["x-trace-id"] = correlation.trace_id;
    if (correlation?.request_id) headers["x-request-id"] = correlation.request_id;
    if (correlation?.session_id) headers["x-session-id"] = correlation.session_id;
    if (correlation?.sandbox_id) headers["x-sandbox-id"] = correlation.sandbox_id;
    return headers;
  }

  /**
   * Generate authentication headers for GET requests (no Content-Type).
   */
  private async getGetHeaders(correlation?: CorrelationContext): Promise<Record<string, string>> {
    const token = await generateInternalToken(this.secret);
    const headers: Record<string, string> = {
      Authorization: `Bearer ${token}`,
    };
    if (correlation?.trace_id) headers["x-trace-id"] = correlation.trace_id;
    if (correlation?.request_id) headers["x-request-id"] = correlation.request_id;
    if (correlation?.session_id) headers["x-session-id"] = correlation.session_id;
    if (correlation?.sandbox_id) headers["x-sandbox-id"] = correlation.sandbox_id;
    return headers;
  }

  /**
   * Create a new sandbox for a session.
   */
  async createSandbox(
    request: CreateSandboxRequest,
    correlation?: CorrelationContext
  ): Promise<CreateSandboxResponse> {
    const startTime = Date.now();
    const endpoint = "createSandbox";
    let httpStatus: number | undefined;
    let outcome: "success" | "error" = "error";

    try {
      const headers = await this.getPostHeaders(correlation);
      const response = await fetch(this.createSandboxUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          session_id: request.sessionId,
          sandbox_id: request.sandboxId || null, // Use control-plane-generated ID
          repo_owner: request.repoOwner,
          repo_name: request.repoName,
          control_plane_url: request.controlPlaneUrl,
          sandbox_auth_token: request.sandboxAuthToken,
          snapshot_id: request.snapshotId || null,
          opencode_session_id: request.opencodeSessionId || null,
          provider: request.provider || "anthropic",
          model: request.model || "claude-sonnet-4-6",
          user_env_vars: request.userEnvVars || null,
          repo_image_id: request.repoImageId || null,
          repo_image_sha: request.repoImageSha || null,
          timeout_seconds: request.timeoutSeconds || null,
          branch: request.branch || null,
        }),
      });

      httpStatus = response.status;

      if (!response.ok) {
        const text = await response.text();
        throw new ModalApiError(`Modal API error: ${response.status} ${text}`, response.status);
      }

      const result = (await response.json()) as ModalApiResponse<{
        sandbox_id: string;
        modal_object_id?: string;
        status: string;
        created_at: number;
      }>;

      if (!result.success || !result.data) {
        throw new Error(`Modal API error: ${result.error || "Unknown error"}`);
      }

      outcome = "success";
      return {
        sandboxId: result.data.sandbox_id,
        modalObjectId: result.data.modal_object_id,
        status: result.data.status,
        createdAt: result.data.created_at,
      };
    } finally {
      log.info("modal.request", {
        event: "modal.request",
        endpoint,
        session_id: request.sessionId,
        sandbox_id: request.sandboxId,
        trace_id: correlation?.trace_id,
        request_id: correlation?.request_id,
        http_status: httpStatus,
        duration_ms: Date.now() - startTime,
        outcome,
      });
    }
  }

  /**
   * Restore a sandbox from a snapshot image.
   */
  async restoreSandbox(
    request: RestoreSandboxRequest,
    correlation?: CorrelationContext
  ): Promise<RestoreSandboxResponse> {
    const startTime = Date.now();
    const endpoint = "restoreSandbox";
    let httpStatus: number | undefined;
    let outcome: "success" | "error" = "error";

    try {
      const headers = await this.getPostHeaders(correlation);
      const response = await fetch(this.restoreSandboxUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          snapshot_image_id: request.snapshotImageId,
          session_config: {
            session_id: request.sessionId,
            repo_owner: request.repoOwner,
            repo_name: request.repoName,
            provider: request.provider,
            model: request.model,
            branch: request.branch || null,
          },
          sandbox_id: request.sandboxId,
          control_plane_url: request.controlPlaneUrl,
          sandbox_auth_token: request.sandboxAuthToken,
          user_env_vars: request.userEnvVars || null,
          timeout_seconds: request.timeoutSeconds || null,
        }),
      });

      httpStatus = response.status;

      if (!response.ok) {
        const text = await response.text();
        throw new ModalApiError(`Modal API error: ${response.status} ${text}`, response.status);
      }

      const result = (await response.json()) as ModalApiResponse<{
        sandbox_id: string;
        modal_object_id?: string;
      }>;

      if (!result.success) {
        return { success: false, error: result.error || "Unknown restore error" };
      }

      outcome = "success";
      return {
        success: true,
        sandboxId: result.data?.sandbox_id,
        modalObjectId: result.data?.modal_object_id,
      };
    } finally {
      log.info("modal.request", {
        event: "modal.request",
        endpoint,
        session_id: request.sessionId,
        sandbox_id: request.sandboxId,
        trace_id: correlation?.trace_id,
        request_id: correlation?.request_id,
        http_status: httpStatus,
        duration_ms: Date.now() - startTime,
        outcome,
      });
    }
  }

  /**
   * Trigger a filesystem snapshot for a sandbox object.
   */
  async snapshotSandbox(
    request: SnapshotSandboxRequest,
    correlation?: CorrelationContext
  ): Promise<SnapshotSandboxResponse> {
    const startTime = Date.now();
    const endpoint = "snapshotSandbox";
    let httpStatus: number | undefined;
    let outcome: "success" | "error" = "error";

    try {
      const headers = await this.getPostHeaders(correlation);
      const response = await fetch(this.snapshotSandboxUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          sandbox_id: request.providerObjectId,
          session_id: request.sessionId,
          reason: request.reason,
        }),
      });

      httpStatus = response.status;

      if (!response.ok) {
        const text = await response.text();
        throw new ModalApiError(`Modal API error: ${response.status} ${text}`, response.status);
      }

      const result = (await response.json()) as ModalApiResponse<{ image_id: string }>;
      if (!result.success) {
        return { success: false, error: result.error || "Unknown snapshot error" };
      }

      if (!result.data?.image_id) {
        return { success: false, error: "Snapshot response missing image_id" };
      }

      outcome = "success";
      return { success: true, imageId: result.data.image_id };
    } finally {
      log.info("modal.request", {
        event: "modal.request",
        endpoint,
        session_id: request.sessionId,
        sandbox_id: request.providerObjectId,
        trace_id: correlation?.trace_id,
        request_id: correlation?.request_id,
        http_status: httpStatus,
        duration_ms: Date.now() - startTime,
        outcome,
      });
    }
  }

  /**
   * Pre-warm a sandbox for faster startup.
   */
  async warmSandbox(
    request: WarmSandboxRequest,
    correlation?: CorrelationContext
  ): Promise<WarmSandboxResponse> {
    const startTime = Date.now();
    const endpoint = "warmSandbox";
    let httpStatus: number | undefined;
    let outcome: "success" | "error" = "error";

    try {
      const headers = await this.getPostHeaders(correlation);
      const response = await fetch(this.warmSandboxUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          repo_owner: request.repoOwner,
          repo_name: request.repoName,
          control_plane_url: request.controlPlaneUrl || "",
        }),
      });

      httpStatus = response.status;

      if (!response.ok) {
        const text = await response.text();
        throw new ModalApiError(`Modal API error: ${response.status} ${text}`, response.status);
      }

      const result = (await response.json()) as ModalApiResponse<{
        sandbox_id: string;
        status: string;
      }>;

      if (!result.success || !result.data) {
        throw new Error(`Modal API error: ${result.error || "Unknown error"}`);
      }

      outcome = "success";
      return {
        sandboxId: result.data.sandbox_id,
        status: result.data.status,
      };
    } finally {
      log.info("modal.request", {
        event: "modal.request",
        endpoint,
        repo_owner: request.repoOwner,
        repo_name: request.repoName,
        trace_id: correlation?.trace_id,
        request_id: correlation?.request_id,
        http_status: httpStatus,
        duration_ms: Date.now() - startTime,
        outcome,
      });
    }
  }

  /**
   * Check Modal API health.
   * Note: Health endpoint does not require authentication.
   */
  async health(): Promise<{ status: string; service: string }> {
    const response = await fetch(this.healthUrl);

    if (!response.ok) {
      throw new ModalApiError(`Modal API error: ${response.status}`, response.status);
    }

    const result = (await response.json()) as ModalApiResponse<{
      status: string;
      service: string;
    }>;

    if (!result.success || !result.data) {
      throw new Error(`Modal API error: ${result.error || "Unknown error"}`);
    }

    return result.data;
  }

  /**
   * Get the latest snapshot for a repository.
   */
  async getLatestSnapshot(
    repoOwner: string,
    repoName: string,
    correlation?: CorrelationContext
  ): Promise<SnapshotInfo | null> {
    const url = `${this.snapshotUrl}?repo_owner=${encodeURIComponent(repoOwner)}&repo_name=${encodeURIComponent(repoName)}`;

    const headers = await this.getGetHeaders(correlation);
    const response = await fetch(url, { headers });

    if (!response.ok) {
      return null;
    }

    const result = (await response.json()) as ModalApiResponse<SnapshotInfo>;

    if (!result.success) {
      return null;
    }

    return result.data || null;
  }

  /**
   * Trigger an async image build on Modal.
   */
  async buildRepoImage(
    request: BuildRepoImageRequest,
    correlation?: CorrelationContext
  ): Promise<BuildRepoImageResponse> {
    const startTime = Date.now();
    const endpoint = "buildRepoImage";
    let httpStatus: number | undefined;
    let outcome: "success" | "error" = "error";

    try {
      const headers = await this.getPostHeaders(correlation);
      const response = await fetch(this.buildRepoImageUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          repo_owner: request.repoOwner,
          repo_name: request.repoName,
          default_branch: request.defaultBranch || "main",
          build_id: request.buildId,
          callback_url: request.callbackUrl,
        }),
      });

      httpStatus = response.status;

      if (!response.ok) {
        const text = await response.text();
        throw new ModalApiError(`Modal API error: ${response.status} ${text}`, response.status);
      }

      const result = (await response.json()) as ModalApiResponse<{
        build_id: string;
        status: string;
      }>;

      if (!result.success || !result.data) {
        throw new Error(`Modal API error: ${result.error || "Unknown error"}`);
      }

      outcome = "success";
      return {
        buildId: result.data.build_id,
        status: result.data.status,
      };
    } finally {
      log.info("modal.request", {
        event: "modal.request",
        endpoint,
        build_id: request.buildId,
        repo_owner: request.repoOwner,
        repo_name: request.repoName,
        trace_id: correlation?.trace_id,
        request_id: correlation?.request_id,
        http_status: httpStatus,
        duration_ms: Date.now() - startTime,
        outcome,
      });
    }
  }

  /**
   * Delete a provider image (best-effort).
   */
  async deleteProviderImage(
    request: DeleteProviderImageRequest,
    correlation?: CorrelationContext
  ): Promise<DeleteProviderImageResponse> {
    const startTime = Date.now();
    const endpoint = "deleteProviderImage";
    let httpStatus: number | undefined;
    let outcome: "success" | "error" = "error";

    try {
      const headers = await this.getPostHeaders(correlation);
      const response = await fetch(this.deleteProviderImageUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          provider_image_id: request.providerImageId,
        }),
      });

      httpStatus = response.status;

      if (!response.ok) {
        const text = await response.text();
        throw new ModalApiError(`Modal API error: ${response.status} ${text}`, response.status);
      }

      const result = (await response.json()) as ModalApiResponse<{
        provider_image_id: string;
        deleted: boolean;
      }>;

      if (!result.success || !result.data) {
        throw new Error(`Modal API error: ${result.error || "Unknown error"}`);
      }

      outcome = "success";
      return {
        providerImageId: result.data.provider_image_id,
        deleted: result.data.deleted,
      };
    } finally {
      log.info("modal.request", {
        event: "modal.request",
        endpoint,
        provider_image_id: request.providerImageId,
        trace_id: correlation?.trace_id,
        request_id: correlation?.request_id,
        http_status: httpStatus,
        duration_ms: Date.now() - startTime,
        outcome,
      });
    }
  }
}

/**
 * Create a new Modal client instance.
 *
 * This is a simple factory function that creates a new client each time.
 * The caller is responsible for managing the client lifecycle.
 *
 * @param secret - The MODAL_API_SECRET for authentication
 * @param workspace - The Modal workspace name (used in endpoint URLs)
 * @returns A new ModalClient instance
 * @throws Error if secret or workspace is not provided
 */
export function createModalClient(secret: string, workspace: string): ModalClient {
  if (!secret) {
    throw new Error("MODAL_API_SECRET is required to create ModalClient");
  }
  if (!workspace) {
    throw new Error("MODAL_WORKSPACE is required to create ModalClient");
  }
  return new ModalClient(secret, workspace);
}
