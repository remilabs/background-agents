/**
 * Sandbox provider interface.
 *
 * Defines a pluggable abstraction for sandbox providers (Modal, Fly.io, Docker, etc.)
 * enabling unit testing and future provider support.
 */

/** Default sandbox lifetime in seconds (2 hours). */
export const DEFAULT_SANDBOX_TIMEOUT_SECONDS = 7200;

/**
 * Capabilities supported by a sandbox provider.
 * Providers can support different feature sets.
 */
export interface SandboxProviderCapabilities {
  /** Whether the provider supports filesystem snapshots */
  supportsSnapshots: boolean;
  /** Whether the provider supports restoring from snapshots */
  supportsRestore: boolean;
  /** Whether the provider supports pre-warming sandboxes */
  supportsWarm: boolean;
}

/**
 * Configuration for creating a new sandbox.
 */
export interface CreateSandboxConfig {
  /** Session ID for WebSocket routing */
  sessionId: string;
  /** Expected sandbox ID (generated by control plane) */
  sandboxId: string;
  /** Repository owner */
  repoOwner: string;
  /** Repository name */
  repoName: string;
  /** Control plane URL for sandbox callbacks */
  controlPlaneUrl: string;
  /** Authentication token for sandbox */
  sandboxAuthToken: string;
  /** LLM provider (e.g., "anthropic") */
  provider: string;
  /** LLM model (e.g., "claude-sonnet-4-5") */
  model: string;
  /** User-provided environment variables (repo secrets) */
  userEnvVars?: Record<string, string>;
  /** OpenCode session ID for resumption */
  opencodeSessionId?: string;
  /** Trace ID for correlation */
  traceId?: string;
  /** Request ID for correlation */
  requestId?: string;
  /** Opaque provider image ID of a pre-built repo image */
  repoImageId?: string | null;
  /** Git SHA the repo image was built from */
  repoImageSha?: string | null;
  /** Git branch to work on (defaults to repo's default branch) */
  branch?: string;
}

/**
 * Result of creating a sandbox.
 */
export interface CreateSandboxResult {
  /** The sandbox ID (should match expected ID from config) */
  sandboxId: string;
  /** Provider's internal object ID (e.g., Modal's object ID for snapshot API) */
  providerObjectId?: string;
  /** Initial sandbox status */
  status: string;
  /** Creation timestamp */
  createdAt: number;
}

/**
 * Configuration for restoring a sandbox from a snapshot.
 */
export interface RestoreConfig {
  /** Snapshot image ID to restore from */
  snapshotImageId: string;
  /** Session ID for WebSocket routing */
  sessionId: string;
  /** Expected sandbox ID */
  sandboxId: string;
  /** Authentication token for sandbox */
  sandboxAuthToken: string;
  /** Control plane URL for sandbox callbacks */
  controlPlaneUrl: string;
  /** Repository owner */
  repoOwner: string;
  /** Repository name */
  repoName: string;
  /** LLM provider (e.g., "anthropic") */
  provider: string;
  /** LLM model (e.g., "claude-sonnet-4-5") */
  model: string;
  /** User-provided environment variables (repo secrets) */
  userEnvVars?: Record<string, string>;
  /** Sandbox lifetime in seconds. Defaults to DEFAULT_SANDBOX_TIMEOUT_SECONDS. */
  timeoutSeconds?: number;
  /** Git branch to work on (defaults to repo's default branch) */
  branch?: string;
  /** Trace ID for correlation */
  traceId?: string;
  /** Request ID for correlation */
  requestId?: string;
}

/**
 * Result of restoring a sandbox from a snapshot.
 */
export interface RestoreResult {
  /** Whether the restore succeeded */
  success: boolean;
  /** Sandbox ID if successful */
  sandboxId?: string;
  /** Provider's internal object ID (e.g., Modal's object ID for snapshot API) */
  providerObjectId?: string;
  /** Error message if failed */
  error?: string;
}

/**
 * Configuration for taking a sandbox snapshot.
 */
export interface SnapshotConfig {
  /** Provider's internal object ID (e.g., Modal's object ID) */
  providerObjectId: string;
  /** Session ID for context */
  sessionId: string;
  /** Reason for the snapshot (e.g., "inactivity_timeout", "execution_complete") */
  reason: string;
  /** Trace ID for correlation */
  traceId?: string;
  /** Request ID for correlation */
  requestId?: string;
}

/**
 * Result of taking a sandbox snapshot.
 */
export interface SnapshotResult {
  /** Whether the snapshot succeeded */
  success: boolean;
  /** Snapshot image ID if successful */
  imageId?: string;
  /** Error message if failed */
  error?: string;
}

/**
 * Error classification for circuit breaker decisions.
 *
 * Only permanent failures should count toward the circuit breaker threshold.
 * Transient failures (network issues, timeouts) are logged but don't trip the breaker.
 *
 * Transient errors (do NOT count toward circuit breaker):
 * - ETIMEDOUT, ECONNRESET, ECONNREFUSED
 * - HTTP 502, 503, 504 (Bad Gateway, Service Unavailable, Gateway Timeout)
 * - "fetch failed" / network errors
 *
 * Permanent errors (DO count toward circuit breaker):
 * - HTTP 400, 401, 403, 422 (Bad Request, Unauthorized, Forbidden, Unprocessable)
 * - Invalid configuration
 * - Resource quota exceeded
 */
export type SandboxErrorType = "transient" | "permanent";

/**
 * Custom error class for sandbox provider operations.
 *
 * Includes error type classification for circuit breaker handling.
 * The circuit breaker only counts permanent errors toward its threshold.
 */
export class SandboxProviderError extends Error {
  constructor(
    message: string,
    public readonly errorType: SandboxErrorType,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = "SandboxProviderError";
    // Maintain proper stack trace in V8 environments
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, SandboxProviderError);
    }
  }

  /**
   * Check if an HTTP status code indicates a transient error.
   */
  static isTransientStatus(status: number): boolean {
    return status === 502 || status === 503 || status === 504;
  }

  /**
   * Check if an error is likely a transient network error.
   */
  static isTransientNetworkError(error: unknown): boolean {
    if (error instanceof Error) {
      const message = error.message.toLowerCase();
      return (
        message.includes("fetch failed") ||
        message.includes("etimedout") ||
        message.includes("econnreset") ||
        message.includes("econnrefused") ||
        message.includes("network") ||
        message.includes("timeout")
      );
    }
    return false;
  }

  /**
   * Create a SandboxProviderError from a fetch error or HTTP response.
   */
  static fromFetchError(message: string, error: unknown, status?: number): SandboxProviderError {
    // Classify based on HTTP status if available
    if (status !== undefined) {
      const errorType = SandboxProviderError.isTransientStatus(status) ? "transient" : "permanent";
      return new SandboxProviderError(
        message,
        errorType,
        error instanceof Error ? error : undefined
      );
    }

    // Classify based on error type
    const errorType = SandboxProviderError.isTransientNetworkError(error)
      ? "transient"
      : "permanent";
    return new SandboxProviderError(message, errorType, error instanceof Error ? error : undefined);
  }
}

/**
 * Sandbox provider interface.
 *
 * Defines the contract for sandbox lifecycle operations.
 * Implementations wrap provider-specific APIs (Modal, Fly.io, Docker, etc.)
 *
 * Error handling:
 * - Methods should throw SandboxProviderError with appropriate errorType
 * - "transient" errors (network issues) don't count toward circuit breaker
 * - "permanent" errors (config issues) do count toward circuit breaker
 *
 * @example
 * ```typescript
 * const provider: SandboxProvider = new ModalSandboxProvider(client, secret);
 *
 * try {
 *   const result = await provider.createSandbox(config);
 *   console.log("Created:", result.sandboxId);
 * } catch (e) {
 *   if (e instanceof SandboxProviderError && e.errorType === "permanent") {
 *     // Increment circuit breaker
 *   }
 *   // Both types set sandbox status to "failed"
 * }
 * ```
 */
export interface SandboxProvider {
  /** Provider name for logging and debugging */
  readonly name: string;

  /** Provider capabilities */
  readonly capabilities: SandboxProviderCapabilities;

  /**
   * Create a new sandbox.
   *
   * @param config - Sandbox configuration
   * @returns Creation result with sandbox ID and status
   * @throws SandboxProviderError with errorType for circuit breaker handling
   */
  createSandbox(config: CreateSandboxConfig): Promise<CreateSandboxResult>;

  /**
   * Restore a sandbox from a filesystem snapshot.
   *
   * Only available if `capabilities.supportsRestore` is true.
   *
   * @param config - Restore configuration with snapshot image ID
   * @returns Result indicating success or failure
   * @throws SandboxProviderError with errorType for circuit breaker handling
   */
  restoreFromSnapshot?(config: RestoreConfig): Promise<RestoreResult>;

  /**
   * Take a filesystem snapshot of the sandbox.
   *
   * Only available if `capabilities.supportsSnapshots` is true.
   *
   * @param config - Snapshot configuration with provider object ID
   * @returns Result with snapshot image ID if successful
   * @throws SandboxProviderError with errorType for error handling
   */
  takeSnapshot?(config: SnapshotConfig): Promise<SnapshotResult>;
}
