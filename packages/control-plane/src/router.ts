/**
 * API router for Open-Inspect Control Plane.
 */

import type { Env, CreateSessionResponse } from "./types";
import { generateId, encryptToken } from "./auth/crypto";
import { verifyInternalToken } from "@open-inspect/shared";
import {
  resolveScmProviderFromEnv,
  SourceControlProviderError,
  type SourceControlProviderName,
} from "./source-control";
import { SessionIndexStore } from "./db/session-index";
import { UserScmTokenStore, DEFAULT_TOKEN_LIFETIME_MS } from "./db/user-scm-tokens";

import {
  getValidModelOrDefault,
  isValidReasoningEffort,
  type SessionStatus,
  type SpawnChildSessionRequest,
  type SpawnContext,
} from "@open-inspect/shared";
import { createRequestMetrics, instrumentD1 } from "./db/instrumented-d1";
import { createLogger } from "./logger";
import {
  type Route,
  type RequestContext,
  parsePattern,
  json,
  error,
  createRouteSourceControlProvider,
  resolveInstalledRepo,
} from "./routes/shared";
import { integrationSettingsRoutes } from "./routes/integration-settings";
import { modelPreferencesRoutes } from "./routes/model-preferences";
import { reposRoutes } from "./routes/repos";
import { repoImageRoutes } from "./routes/repo-images";
import { secretsRoutes } from "./routes/secrets";
import { z, ZodError } from "zod";

const logger = createLogger("router");

// Guardrail constants for agent-spawned child sessions
const MAX_SPAWN_DEPTH = 2;
const MAX_CONCURRENT_CHILDREN = 5;
const MAX_TOTAL_CHILDREN = 15;

const SESSION_STATUSES: SessionStatus[] = [
  "created",
  "active",
  "completed",
  "failed",
  "archived",
  "cancelled",
];

function parseSessionStatus(value: string | null): SessionStatus | undefined {
  if (!value) return undefined;
  return SESSION_STATUSES.includes(value as SessionStatus) ? (value as SessionStatus) : undefined;
}

// ── Zod schemas for request body validation ──

const CreateSessionSchema = z.object({
  repoOwner: z.string().min(1, "repoOwner is required"),
  repoName: z.string().min(1, "repoName is required"),
  title: z.string().optional(),
  model: z.string().optional(),
  reasoningEffort: z.string().optional(),
  branch: z.string().optional(),
  scmToken: z.string().optional(),
  userId: z.string().optional(),
  scmLogin: z.string().optional(),
  scmName: z.string().optional(),
  scmEmail: z.string().optional(),
});

const PromptSchema = z.object({
  content: z.string().min(1, "content is required"),
  authorId: z.string().optional(),
  source: z.string().optional(),
  model: z.string().optional(),
  reasoningEffort: z.string().optional(),
  attachments: z
    .array(
      z.object({
        type: z.enum(["file", "image", "url"]),
        name: z.string(),
        url: z.string().optional(),
        content: z.string().optional(),
        mimeType: z.string().optional(),
      })
    )
    .optional(),
  // Validates against SlackCallbackContext | LinearCallbackContext from @open-inspect/shared
  callbackContext: z
    .union([
      z.object({
        source: z.literal("slack"),
        channel: z.string(),
        threadTs: z.string(),
        repoFullName: z.string(),
        model: z.string(),
        reasoningEffort: z.string().optional(),
        reactionMessageTs: z.string().optional(),
      }),
      z.object({
        source: z.literal("linear"),
        issueId: z.string(),
        issueIdentifier: z.string(),
        issueUrl: z.string(),
        repoFullName: z.string(),
        model: z.string(),
        agentSessionId: z.string().optional(),
        organizationId: z.string().optional(),
      }),
    ])
    .optional(),
});

const WsTokenSchema = z.object({
  userId: z.string().min(1, "userId is required"),
  scmUserId: z.string().optional(),
  scmLogin: z.string().optional(),
  scmName: z.string().optional(),
  scmEmail: z.string().optional(),
  scmToken: z.string().optional(),
  scmTokenExpiresAt: z.number().optional(),
  scmRefreshToken: z.string().optional(),
});

const AddParticipantSchema = z.object({
  userId: z.string().min(1, "userId is required"),
  scmLogin: z.string().optional(),
  scmName: z.string().optional(),
  scmEmail: z.string().optional(),
  role: z.string().optional(),
});

const ArchiveSchema = z.object({
  userId: z.string().min(1, "userId is required"),
});

const CreatePRSchema = z.object({
  title: z.string().min(1, "title is required"),
  body: z.string().min(1, "body is required"),
  baseBranch: z.string().optional(),
  headBranch: z.string().optional(),
});

/**
 * Format a ZodError into a human-readable string for 400 responses.
 */
function formatZodError(err: ZodError): string {
  return err.issues.map((i) => `${i.path.join(".")}: ${i.message}`).join("; ");
}

/**
 * Create a Request to a Durable Object stub with correlation headers.
 * Ensures trace_id and request_id propagate into the DO.
 */
function internalRequest(url: string, init: RequestInit | undefined, ctx: RequestContext): Request {
  const headers = new Headers(init?.headers);
  headers.set("x-trace-id", ctx.trace_id);
  headers.set("x-request-id", ctx.request_id);
  return new Request(url, { ...init, headers });
}

/**
 * Return the request origin if it matches the configured WEB_APP_URL, or null otherwise.
 * When the Origin header is absent (e.g. same-origin or non-browser requests), no
 * Access-Control-Allow-Origin header will be set, which is the correct behaviour.
 */
export function getAllowedOrigin(requestOrigin: string | null, env: Env): string | null {
  if (!requestOrigin || !env.WEB_APP_URL) return null;
  // Compare origin against the configured web app URL (strip trailing slash for safety)
  const allowed = env.WEB_APP_URL.replace(/\/+$/, "");
  return requestOrigin === allowed ? requestOrigin : null;
}

function withCorsAndTraceHeaders(
  response: Response,
  ctx: RequestContext,
  allowedOrigin: string | null
): Response {
  const headers = new Headers(response.headers);
  if (allowedOrigin) {
    headers.set("Access-Control-Allow-Origin", allowedOrigin);
    headers.set("Vary", "Origin");
  }
  headers.set("x-request-id", ctx.request_id);
  headers.set("x-trace-id", ctx.trace_id);
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers,
  });
}

/**
 * Get Durable Object stub for a session.
 * Returns the stub or null if session ID is missing.
 */
function getSessionStub(env: Env, match: RegExpMatchArray): DurableObjectStub | null {
  const sessionId = match.groups?.id;
  if (!sessionId) return null;

  const doId = env.SESSION.idFromName(sessionId);
  return env.SESSION.get(doId);
}

/**
 * Routes that do not require authentication.
 */
const PUBLIC_ROUTES: RegExp[] = [/^\/health$/];

/**
 * Routes that accept sandbox authentication.
 * These are session-specific routes that can be called by sandboxes using their auth token.
 * The sandbox token is validated by the Durable Object.
 */
const SANDBOX_AUTH_ROUTES: RegExp[] = [
  /^\/sessions\/[^/]+\/pr$/, // PR creation from sandbox
  /^\/sessions\/[^/]+\/openai-token-refresh$/, // OpenAI token refresh from sandbox
  /^\/sessions\/[^/]+\/children$/, // POST spawn, GET list
  /^\/sessions\/[^/]+\/children\/[^/]+$/, // GET child detail
  /^\/sessions\/[^/]+\/children\/[^/]+\/cancel$/, // POST cancel child
];

type CachedScmProvider =
  | {
      envValue: string | undefined;
      provider: SourceControlProviderName;
      error?: never;
    }
  | {
      envValue: string | undefined;
      provider?: never;
      error: SourceControlProviderError;
    };

let cachedScmProvider: CachedScmProvider | null = null;

function resolveDeploymentScmProvider(env: Env): SourceControlProviderName {
  const envValue = env.SCM_PROVIDER;
  if (!cachedScmProvider || cachedScmProvider.envValue !== envValue) {
    try {
      cachedScmProvider = {
        envValue,
        provider: resolveScmProviderFromEnv(envValue),
      };
    } catch (errorValue) {
      cachedScmProvider = {
        envValue,
        error:
          errorValue instanceof SourceControlProviderError
            ? errorValue
            : new SourceControlProviderError("Invalid SCM provider configuration", "permanent"),
      };
    }
  }

  if (cachedScmProvider.error) {
    throw cachedScmProvider.error;
  }

  return cachedScmProvider.provider;
}

/**
 * Check if a path matches any public route pattern.
 */
function isPublicRoute(path: string): boolean {
  return PUBLIC_ROUTES.some((pattern) => pattern.test(path));
}

/**
 * Check if a path matches any sandbox auth route pattern.
 */
function isSandboxAuthRoute(path: string): boolean {
  return SANDBOX_AUTH_ROUTES.some((pattern) => pattern.test(path));
}

function enforceImplementedScmProvider(
  path: string,
  env: Env,
  ctx: RequestContext,
  allowedOrigin: string | null
): Response | null {
  try {
    const provider = resolveDeploymentScmProvider(env);
    if (provider !== "github" && !isPublicRoute(path)) {
      logger.warn("SCM provider not implemented", {
        event: "scm.provider_not_implemented",
        scm_provider: provider,
        http_path: path,
        request_id: ctx.request_id,
        trace_id: ctx.trace_id,
      });
      const response = error(
        `SCM provider '${provider}' is not implemented in this deployment.`,
        501
      );
      return withCorsAndTraceHeaders(response, ctx, allowedOrigin);
    }

    return null;
  } catch (errorValue) {
    const errorMessage =
      errorValue instanceof SourceControlProviderError
        ? errorValue.message
        : "Invalid SCM provider configuration";

    logger.error("Invalid SCM provider configuration", {
      event: "scm.provider_invalid",
      error: errorValue instanceof Error ? errorValue : String(errorValue),
      request_id: ctx.request_id,
      trace_id: ctx.trace_id,
    });

    const response = error(errorMessage, 500);
    return withCorsAndTraceHeaders(response, ctx, allowedOrigin);
  }
}

/**
 * Validate sandbox authentication by checking with the Durable Object.
 * The DO stores the expected sandbox auth token.
 *
 * @param request - The incoming request
 * @param env - Environment bindings
 * @param sessionId - Session ID extracted from path
 * @param ctx - Request correlation context
 * @returns null if authentication passes, or an error Response to return immediately
 */
async function verifySandboxAuth(
  request: Request,
  env: Env,
  sessionId: string,
  ctx: RequestContext
): Promise<Response | null> {
  const authHeader = request.headers.get("Authorization");
  if (!authHeader?.startsWith("Bearer ")) {
    return error("Unauthorized: Missing sandbox token", 401);
  }

  const token = authHeader.slice(7); // Remove "Bearer " prefix

  // Ask the Durable Object to validate this sandbox token
  const doId = env.SESSION.idFromName(sessionId);
  const stub = env.SESSION.get(doId);

  const verifyResponse = await stub.fetch(
    internalRequest(
      "http://internal/internal/verify-sandbox-token",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token }),
      },
      ctx
    )
  );

  if (!verifyResponse.ok) {
    const clientIP = request.headers.get("CF-Connecting-IP") || "unknown";
    logger.warn("Auth failed: sandbox", {
      event: "auth.sandbox_failed",
      http_path: new URL(request.url).pathname,
      client_ip: clientIP,
      session_id: sessionId,
      request_id: ctx.request_id,
      trace_id: ctx.trace_id,
    });
    return error("Unauthorized: Invalid sandbox token", 401);
  }

  return null; // Auth passed
}

/**
 * Require internal API authentication for service-to-service calls.
 * Fails closed: returns error response if secret is not configured or token is invalid.
 *
 * @param request - The incoming request
 * @param env - Environment bindings
 * @param path - Request path for logging
 * @param ctx - Request correlation context
 * @returns null if authentication passes, or an error Response to return immediately
 */
async function requireInternalAuth(
  request: Request,
  env: Env,
  path: string,
  ctx: RequestContext
): Promise<Response | null> {
  if (!env.INTERNAL_CALLBACK_SECRET) {
    logger.error("INTERNAL_CALLBACK_SECRET not configured - rejecting request", {
      event: "auth.misconfigured",
      request_id: ctx.request_id,
      trace_id: ctx.trace_id,
    });
    return error("Internal authentication not configured", 500);
  }

  const isValid = await verifyInternalToken(
    request.headers.get("Authorization"),
    env.INTERNAL_CALLBACK_SECRET
  );

  if (!isValid) {
    const clientIP = request.headers.get("CF-Connecting-IP") || "unknown";
    logger.warn("Auth failed: HMAC", {
      event: "auth.hmac_failed",
      http_path: path,
      client_ip: clientIP,
      request_id: ctx.request_id,
      trace_id: ctx.trace_id,
    });
    return error("Unauthorized", 401);
  }

  return null; // Auth passed
}

/**
 * Routes definition.
 */
const routes: Route[] = [
  // Health check
  {
    method: "GET",
    pattern: parsePattern("/health"),
    handler: async () => json({ status: "healthy", service: "open-inspect-control-plane" }),
  },

  // Session management
  {
    method: "GET",
    pattern: parsePattern("/sessions"),
    handler: handleListSessions,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions"),
    handler: handleCreateSession,
  },
  {
    method: "GET",
    pattern: parsePattern("/sessions/:id"),
    handler: handleGetSession,
  },
  {
    method: "DELETE",
    pattern: parsePattern("/sessions/:id"),
    handler: handleDeleteSession,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/prompt"),
    handler: handleSessionPrompt,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/stop"),
    handler: handleSessionStop,
  },
  {
    method: "GET",
    pattern: parsePattern("/sessions/:id/events"),
    handler: handleSessionEvents,
  },
  {
    method: "GET",
    pattern: parsePattern("/sessions/:id/artifacts"),
    handler: handleSessionArtifacts,
  },
  {
    method: "GET",
    pattern: parsePattern("/sessions/:id/participants"),
    handler: handleSessionParticipants,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/participants"),
    handler: handleAddParticipant,
  },
  {
    method: "GET",
    pattern: parsePattern("/sessions/:id/messages"),
    handler: handleSessionMessages,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/pr"),
    handler: handleCreatePR,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/openai-token-refresh"),
    handler: handleOpenAITokenRefresh,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/ws-token"),
    handler: handleSessionWsToken,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/archive"),
    handler: handleArchiveSession,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/unarchive"),
    handler: handleUnarchiveSession,
  },

  // Child session management (sandbox-authenticated)
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/children"),
    handler: handleSpawnChild,
  },
  {
    method: "GET",
    pattern: parsePattern("/sessions/:id/children"),
    handler: handleListChildren,
  },
  {
    method: "GET",
    pattern: parsePattern("/sessions/:id/children/:childId"),
    handler: handleGetChild,
  },
  {
    method: "POST",
    pattern: parsePattern("/sessions/:id/children/:childId/cancel"),
    handler: handleCancelChild,
  },

  // Repository management
  ...reposRoutes,

  // Secrets
  ...secretsRoutes,

  // Model preferences
  ...modelPreferencesRoutes,

  // Integration settings
  ...integrationSettingsRoutes,

  // Repo image builds
  ...repoImageRoutes,
];

/**
 * Match request to route and execute handler.
 */
export async function handleRequest(
  request: Request,
  env: Env,
  executionCtx?: ExecutionContext
): Promise<Response> {
  const url = new URL(request.url);
  const path = url.pathname;
  const method = request.method;
  const startTime = Date.now();

  // Build correlation context with per-request metrics
  const metrics = createRequestMetrics();
  const ctx: RequestContext = {
    trace_id: request.headers.get("x-trace-id") || crypto.randomUUID(),
    request_id: crypto.randomUUID().slice(0, 8),
    metrics,
    executionCtx,
  };

  // Instrument D1 so all queries are automatically timed
  const instrumentedEnv: Env = { ...env, DB: instrumentD1(env.DB, metrics) };

  // Resolve allowed CORS origin once for the entire request
  const requestOrigin = request.headers.get("Origin");
  const allowedOrigin = getAllowedOrigin(requestOrigin, env);

  // CORS preflight
  if (method === "OPTIONS") {
    const preflightHeaders: Record<string, string> = {
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Max-Age": "86400",
      "x-request-id": ctx.request_id,
      "x-trace-id": ctx.trace_id,
    };
    if (allowedOrigin) {
      preflightHeaders["Access-Control-Allow-Origin"] = allowedOrigin;
      preflightHeaders["Vary"] = "Origin";
    }
    return new Response(null, { headers: preflightHeaders });
  }

  // Require authentication for non-public routes
  if (!isPublicRoute(path)) {
    // First try HMAC auth (for web app, slack bot, etc.)
    const hmacAuthError = await requireInternalAuth(request, env, path, ctx);

    if (hmacAuthError) {
      // HMAC auth failed - check if this route accepts sandbox auth
      if (isSandboxAuthRoute(path)) {
        // Extract session ID from path (e.g., /sessions/abc123/pr -> abc123)
        const sessionIdMatch = path.match(/^\/sessions\/([^/]+)\//);
        if (sessionIdMatch) {
          const sessionId = sessionIdMatch[1];
          const sandboxAuthError = await verifySandboxAuth(request, env, sessionId, ctx);
          if (!sandboxAuthError) {
            // Sandbox auth passed, continue to route handler
          } else {
            // Both HMAC and sandbox auth failed
            return withCorsAndTraceHeaders(sandboxAuthError, ctx, allowedOrigin);
          }
        }
      } else {
        // Not a sandbox auth route, return HMAC auth error
        return withCorsAndTraceHeaders(hmacAuthError, ctx, allowedOrigin);
      }
    }
  }

  const providerCheck = enforceImplementedScmProvider(path, env, ctx, allowedOrigin);
  if (providerCheck) {
    return providerCheck;
  }

  // Find matching route
  for (const route of routes) {
    if (route.method !== method) continue;

    const match = path.match(route.pattern);
    if (match) {
      let response: Response;
      let outcome: "success" | "error";
      try {
        response = await route.handler(request, instrumentedEnv, match, ctx);
        outcome = response.status >= 500 ? "error" : "success";
      } catch (e) {
        const durationMs = Date.now() - startTime;
        logger.error("http.request", {
          event: "http.request",
          request_id: ctx.request_id,
          trace_id: ctx.trace_id,
          http_method: method,
          http_path: path,
          http_status: 500,
          duration_ms: durationMs,
          outcome: "error",
          error: e instanceof Error ? e : String(e),
          ...ctx.metrics.summarize(),
        });
        return error("Internal server error", 500);
      }

      const durationMs = Date.now() - startTime;
      logger.info("http.request", {
        event: "http.request",
        request_id: ctx.request_id,
        trace_id: ctx.trace_id,
        http_method: method,
        http_path: path,
        http_status: response.status,
        duration_ms: durationMs,
        outcome,
        ...ctx.metrics.summarize(),
      });

      return withCorsAndTraceHeaders(response, ctx, allowedOrigin);
    }
  }

  return error("Not found", 404);
}

// Session handlers

async function handleListSessions(
  request: Request,
  env: Env,
  _match: RegExpMatchArray,
  _ctx: RequestContext
): Promise<Response> {
  const url = new URL(request.url);
  const limit = Math.min(parseInt(url.searchParams.get("limit") || "50"), 100);
  const offset = parseInt(url.searchParams.get("offset") || "0");
  const statusParam = url.searchParams.get("status");
  const excludeStatusParam = url.searchParams.get("excludeStatus");
  const status = parseSessionStatus(statusParam);
  const excludeStatus = parseSessionStatus(excludeStatusParam);

  if (statusParam && !status) {
    return error("Invalid status", 400);
  }

  if (excludeStatusParam && !excludeStatus) {
    return error("Invalid excludeStatus", 400);
  }

  const store = new SessionIndexStore(env.DB);
  const result = await store.list({ status, excludeStatus, limit, offset });

  return json({
    sessions: result.sessions,
    total: result.total,
    hasMore: result.hasMore,
  });
}

async function handleCreateSession(
  request: Request,
  env: Env,
  _match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  let body: z.infer<typeof CreateSessionSchema>;
  try {
    body = CreateSessionSchema.parse(await request.json());
  } catch (e) {
    if (e instanceof ZodError) {
      return error(`Invalid request body: ${formatZodError(e)}`);
    }
    return error("Invalid JSON body");
  }

  // Validate branch name if provided (defense in depth)
  if (body.branch && !/^[\w.\-/]+$/.test(body.branch)) {
    return error("Invalid branch name");
  }

  // Normalize repo identifiers to lowercase for consistent storage
  const repoOwner = body.repoOwner.toLowerCase();
  const repoName = body.repoName.toLowerCase();

  let repoId: number;
  let defaultBranch: string;
  try {
    const provider = createRouteSourceControlProvider(env);
    const resolved = await resolveInstalledRepo(provider, repoOwner, repoName);
    if (!resolved) {
      return error("Repository is not installed for the GitHub App", 404);
    }
    repoId = resolved.repoId;
    defaultBranch = resolved.defaultBranch;
  } catch (e) {
    const message = e instanceof Error ? e.message : String(e);
    logger.error("Failed to resolve repository", {
      error: message,
      repo_owner: repoOwner,
      repo_name: repoName,
    });
    const isConfigError =
      e instanceof SourceControlProviderError && e.errorType === "permanent" && !e.httpStatus;
    return error(isConfigError ? message : "Failed to resolve repository", 500);
  }

  const userId = body.userId || "anonymous";
  const scmLogin = body.scmLogin;
  const scmName = body.scmName;
  const scmEmail = body.scmEmail;
  const scmToken = body.scmToken;
  let scmTokenEncrypted: string | null = null;

  // If SCM token provided, encrypt it
  if (scmToken && env.TOKEN_ENCRYPTION_KEY) {
    try {
      scmTokenEncrypted = await encryptToken(scmToken, env.TOKEN_ENCRYPTION_KEY);
    } catch (e) {
      logger.error("Failed to encrypt SCM token", {
        error: e instanceof Error ? e : String(e),
      });
      return error("Failed to process SCM token", 500);
    }
  }

  // Generate session ID
  const sessionId = generateId();

  // Get Durable Object
  const doId = env.SESSION.idFromName(sessionId);
  const stub = env.SESSION.get(doId);

  // Validate model and reasoning effort once for both DO init and D1 index
  const model = getValidModelOrDefault(body.model);
  const reasoningEffort =
    body.reasoningEffort && isValidReasoningEffort(model, body.reasoningEffort)
      ? body.reasoningEffort
      : null;

  // Initialize session with user info and optional encrypted token
  const initResponse = await stub.fetch(
    internalRequest(
      "http://internal/internal/init",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sessionName: sessionId, // Pass the session name for WebSocket routing
          repoOwner,
          repoName,
          repoId,
          defaultBranch,
          branch: body.branch,
          title: body.title,
          model,
          reasoningEffort,
          userId,
          scmLogin,
          scmName,
          scmEmail,
          scmTokenEncrypted,
        }),
      },
      ctx
    )
  );

  if (!initResponse.ok) {
    return error("Failed to create session", 500);
  }

  // Store session in D1 index for listing
  const now = Date.now();
  const sessionStore = new SessionIndexStore(env.DB);
  await sessionStore.create({
    id: sessionId,
    title: body.title || null,
    repoOwner,
    repoName,
    model,
    reasoningEffort,
    baseBranch: body.branch || defaultBranch || "main",
    status: "created",
    createdAt: now,
    updatedAt: now,
  });

  const result: CreateSessionResponse = {
    sessionId,
    status: "created",
  };

  return json(result, 201);
}

async function handleGetSession(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const sessionId = match.groups?.id;
  if (!sessionId) return error("Session ID required");

  const doId = env.SESSION.idFromName(sessionId);
  const stub = env.SESSION.get(doId);

  const response = await stub.fetch(
    internalRequest("http://internal/internal/state", undefined, ctx)
  );

  if (!response.ok) {
    return error("Session not found", 404);
  }

  return response;
}

async function handleDeleteSession(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  _ctx: RequestContext
): Promise<Response> {
  const sessionId = match.groups?.id;
  if (!sessionId) return error("Session ID required");

  // Delete from D1 index
  const sessionStore = new SessionIndexStore(env.DB);
  await sessionStore.delete(sessionId);

  // Note: Durable Object data will be garbage collected by Cloudflare
  // when no longer referenced. We could also call a cleanup method on the DO.

  return json({ status: "deleted", sessionId });
}

async function handleSessionPrompt(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const sessionId = match.groups?.id;
  if (!sessionId) return error("Session ID required");

  let body: z.infer<typeof PromptSchema>;
  try {
    body = PromptSchema.parse(await request.json());
  } catch (e) {
    if (e instanceof ZodError) {
      return error(`Invalid request body: ${formatZodError(e)}`);
    }
    return error("Invalid JSON body");
  }

  const doId = env.SESSION.idFromName(sessionId);
  const stub = env.SESSION.get(doId);

  const response = await stub.fetch(
    internalRequest(
      "http://internal/internal/prompt",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          content: body.content,
          authorId: body.authorId || "anonymous",
          source: body.source || "web",
          model: body.model,
          reasoningEffort: body.reasoningEffort,
          attachments: body.attachments,
          callbackContext: body.callbackContext,
        }),
      },
      ctx
    )
  );

  // Background: update D1 timestamp so session bubbles to top of sidebar
  const store = new SessionIndexStore(env.DB);
  ctx.executionCtx?.waitUntil(
    store.touchUpdatedAt(sessionId).catch((error) => {
      logger.error("session_index.touch_updated_at.background_error", {
        session_id: sessionId,
        trace_id: ctx.trace_id,
        request_id: ctx.request_id,
        error,
      });
    })
  );

  return response;
}

async function handleSessionStop(
  _request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const stub = getSessionStub(env, match);
  if (!stub) return error("Session ID required");

  return stub.fetch(internalRequest("http://internal/internal/stop", { method: "POST" }, ctx));
}

async function handleSessionEvents(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const stub = getSessionStub(env, match);
  if (!stub) return error("Session ID required");

  const url = new URL(request.url);
  return stub.fetch(
    internalRequest(`http://internal/internal/events${url.search}`, undefined, ctx)
  );
}

async function handleSessionArtifacts(
  _request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const stub = getSessionStub(env, match);
  if (!stub) return error("Session ID required");

  return stub.fetch(internalRequest("http://internal/internal/artifacts", undefined, ctx));
}

async function handleSessionParticipants(
  _request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const stub = getSessionStub(env, match);
  if (!stub) return error("Session ID required");

  return stub.fetch(internalRequest("http://internal/internal/participants", undefined, ctx));
}

async function handleAddParticipant(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const sessionId = match.groups?.id;
  if (!sessionId) return error("Session ID required");

  let body: z.infer<typeof AddParticipantSchema>;
  try {
    body = AddParticipantSchema.parse(await request.json());
  } catch (e) {
    if (e instanceof ZodError) {
      return error(`Invalid request body: ${formatZodError(e)}`);
    }
    return error("Invalid JSON body");
  }

  const doId = env.SESSION.idFromName(sessionId);
  const stub = env.SESSION.get(doId);

  const response = await stub.fetch(
    internalRequest(
      "http://internal/internal/participants",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      },
      ctx
    )
  );

  return response;
}

async function handleSessionMessages(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const stub = getSessionStub(env, match);
  if (!stub) return error("Session ID required");

  const url = new URL(request.url);
  return stub.fetch(
    internalRequest(`http://internal/internal/messages${url.search}`, undefined, ctx)
  );
}

async function handleCreatePR(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const sessionId = match.groups?.id;
  if (!sessionId) return error("Session ID required");

  let body: z.infer<typeof CreatePRSchema>;
  try {
    body = CreatePRSchema.parse(await request.json());
  } catch (e) {
    if (e instanceof ZodError) {
      return error(`Invalid request body: ${formatZodError(e)}`);
    }
    return error("Invalid JSON body");
  }

  const doId = env.SESSION.idFromName(sessionId);
  const stub = env.SESSION.get(doId);

  const response = await stub.fetch(
    internalRequest(
      "http://internal/internal/create-pr",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      },
      ctx
    )
  );

  return response;
}

async function handleOpenAITokenRefresh(
  _request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const stub = getSessionStub(env, match);
  if (!stub) return error("Session ID required");

  return stub.fetch(
    internalRequest("http://internal/internal/openai-token-refresh", { method: "POST" }, ctx)
  );
}

async function handleSessionWsToken(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const sessionId = match.groups?.id;
  if (!sessionId) return error("Session ID required");

  let body: z.infer<typeof WsTokenSchema>;
  try {
    body = WsTokenSchema.parse(await request.json());
  } catch (e) {
    if (e instanceof ZodError) {
      return error(`Invalid request body: ${formatZodError(e)}`);
    }
    return error("Invalid JSON body");
  }

  const scmUserId = body.scmUserId;
  const scmLogin = body.scmLogin;
  const scmName = body.scmName;
  const scmEmail = body.scmEmail;
  const scmToken = body.scmToken;
  const scmTokenExpiresAt = body.scmTokenExpiresAt;
  const scmRefreshToken = body.scmRefreshToken;

  // Encrypt the SCM tokens if provided
  const { scmTokenEncrypted, scmRefreshTokenEncrypted } = await ctx.metrics.time(
    "encrypt_tokens",
    async () => {
      let accessToken: string | null = null;
      let refreshToken: string | null = null;

      if (scmToken && env.TOKEN_ENCRYPTION_KEY) {
        try {
          accessToken = await encryptToken(scmToken, env.TOKEN_ENCRYPTION_KEY);
        } catch (e) {
          logger.error("Failed to encrypt SCM token", {
            error: e instanceof Error ? e : String(e),
          });
        }
      }

      if (scmRefreshToken && env.TOKEN_ENCRYPTION_KEY) {
        try {
          refreshToken = await encryptToken(scmRefreshToken, env.TOKEN_ENCRYPTION_KEY);
        } catch (e) {
          logger.error("Failed to encrypt SCM refresh token", {
            error: e instanceof Error ? e : String(e),
          });
        }
      }

      return { scmTokenEncrypted: accessToken, scmRefreshTokenEncrypted: refreshToken };
    }
  );

  // Populate D1 with the user's SCM tokens (non-blocking) so centralized refresh works
  if (scmUserId && scmToken && scmRefreshToken && env.TOKEN_ENCRYPTION_KEY) {
    ctx.executionCtx?.waitUntil(
      new UserScmTokenStore(env.DB, env.TOKEN_ENCRYPTION_KEY)
        .upsertTokens(
          scmUserId,
          scmToken,
          scmRefreshToken,
          scmTokenExpiresAt ?? Date.now() + DEFAULT_TOKEN_LIFETIME_MS
        )
        .catch((e) =>
          logger.error("Failed to write tokens to D1", {
            error: e instanceof Error ? e : String(e),
          })
        )
    );
  }

  const doId = env.SESSION.idFromName(sessionId);
  const stub = env.SESSION.get(doId);

  const response = await ctx.metrics.time("do_fetch", () =>
    stub.fetch(
      internalRequest(
        "http://internal/internal/ws-token",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId: body.userId,
            scmUserId,
            scmLogin,
            scmName,
            scmEmail,
            scmTokenEncrypted,
            scmRefreshTokenEncrypted,
            scmTokenExpiresAt,
          }),
        },
        ctx
      )
    )
  );

  return response;
}

async function handleArchiveSession(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const sessionId = match.groups?.id;
  if (!sessionId) return error("Session ID required");

  let body: z.infer<typeof ArchiveSchema>;
  try {
    body = ArchiveSchema.parse(await request.json());
  } catch (e) {
    if (e instanceof ZodError) {
      return error(`Invalid request body: ${formatZodError(e)}`);
    }
    return error("Invalid JSON body");
  }

  const doId = env.SESSION.idFromName(sessionId);
  const stub = env.SESSION.get(doId);

  const response = await stub.fetch(
    internalRequest(
      "http://internal/internal/archive",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userId: body.userId }),
      },
      ctx
    )
  );

  if (response.ok) {
    // Update D1 index
    const sessionStore = new SessionIndexStore(env.DB);
    const updated = await sessionStore.updateStatus(sessionId, "archived");
    if (!updated) {
      logger.warn("Session not found in D1 index during archive", { session_id: sessionId });
    }
  }

  return response;
}

async function handleUnarchiveSession(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const sessionId = match.groups?.id;
  if (!sessionId) return error("Session ID required");

  let body: z.infer<typeof ArchiveSchema>;
  try {
    body = ArchiveSchema.parse(await request.json());
  } catch (e) {
    if (e instanceof ZodError) {
      return error(`Invalid request body: ${formatZodError(e)}`);
    }
    return error("Invalid JSON body");
  }

  const doId = env.SESSION.idFromName(sessionId);
  const stub = env.SESSION.get(doId);

  const response = await stub.fetch(
    internalRequest(
      "http://internal/internal/unarchive",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userId: body.userId }),
      },
      ctx
    )
  );

  if (response.ok) {
    // Update D1 index
    const sessionStore = new SessionIndexStore(env.DB);
    const updated = await sessionStore.updateStatus(sessionId, "active");
    if (!updated) {
      logger.warn("Session not found in D1 index during unarchive", { session_id: sessionId });
    }
  }

  return response;
}

// Child session handlers

async function handleSpawnChild(
  request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const parentId = match.groups?.id;
  if (!parentId) return error("Parent session ID required");

  const body = (await request.json()) as SpawnChildSessionRequest;

  if (!body.title || !body.prompt) {
    return error("title and prompt are required");
  }

  const sessionStore = new SessionIndexStore(env.DB);

  // Guardrail: depth
  const parentDepth = await sessionStore.getSpawnDepth(parentId);
  if (parentDepth >= MAX_SPAWN_DEPTH) {
    return error(`Maximum spawn depth (${MAX_SPAWN_DEPTH}) exceeded`, 403);
  }

  // Guardrail: concurrent children
  const activeCount = await sessionStore.countActiveChildren(parentId);
  if (activeCount >= MAX_CONCURRENT_CHILDREN) {
    return error(`Maximum concurrent children (${MAX_CONCURRENT_CHILDREN}) reached`, 429);
  }

  // Guardrail: total children
  const totalCount = await sessionStore.countTotalChildren(parentId);
  if (totalCount >= MAX_TOTAL_CHILDREN) {
    return error(`Maximum total children (${MAX_TOTAL_CHILDREN}) reached`, 429);
  }

  // Get parent context from parent DO
  const parentDoId = env.SESSION.idFromName(parentId);
  const parentStub = env.SESSION.get(parentDoId);

  const spawnContextRes = await parentStub.fetch(
    internalRequest("http://internal/internal/spawn-context", undefined, ctx)
  );

  if (!spawnContextRes.ok) {
    return error("Failed to get parent session context", 500);
  }

  const spawnContext = (await spawnContextRes.json()) as SpawnContext;

  // Guardrail: same-repo — reject if either field doesn't match parent
  if (
    (body.repoOwner && body.repoOwner.toLowerCase() !== spawnContext.repoOwner.toLowerCase()) ||
    (body.repoName && body.repoName.toLowerCase() !== spawnContext.repoName.toLowerCase())
  ) {
    return error("Child sessions must use the same repository as the parent", 403);
  }

  // Create child session (same pattern as handleCreateSession)
  const childId = generateId();
  const childDoId = env.SESSION.idFromName(childId);
  const childStub = env.SESSION.get(childDoId);

  const model = getValidModelOrDefault(body.model || spawnContext.model);
  const reasoningEffort =
    body.reasoningEffort && isValidReasoningEffort(model, body.reasoningEffort)
      ? body.reasoningEffort
      : spawnContext.reasoningEffort;

  const childDepth = parentDepth + 1;

  logger.info("Spawning child session", {
    event: "session.spawn_child",
    parent_id: parentId,
    child_id: childId,
    child_depth: childDepth,
    model,
  });

  // Initialize child DO
  const initResponse = await childStub.fetch(
    internalRequest(
      "http://internal/internal/init",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sessionName: childId,
          repoOwner: spawnContext.repoOwner,
          repoName: spawnContext.repoName,
          repoId: spawnContext.repoId,
          title: body.title,
          model,
          reasoningEffort,
          userId: spawnContext.owner.userId,
          scmLogin: spawnContext.owner.scmLogin,
          scmName: spawnContext.owner.scmName,
          scmEmail: spawnContext.owner.scmEmail,
          scmTokenEncrypted: spawnContext.owner.scmAccessTokenEncrypted,
          parentSessionId: parentId,
          spawnSource: "agent",
          spawnDepth: childDepth,
        }),
      },
      ctx
    )
  );

  if (!initResponse.ok) {
    return error("Failed to create child session", 500);
  }

  // Store in D1 index
  const now = Date.now();
  await sessionStore.create({
    id: childId,
    title: body.title,
    repoOwner: spawnContext.repoOwner,
    repoName: spawnContext.repoName,
    model,
    reasoningEffort,
    baseBranch: null,
    status: "created",
    parentSessionId: parentId,
    spawnSource: "agent",
    spawnDepth: childDepth,
    createdAt: now,
    updatedAt: now,
  });

  // Enqueue the prompt on the child DO
  let promptResponse: Response;
  try {
    promptResponse = await childStub.fetch(
      internalRequest(
        "http://internal/internal/prompt",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            content: body.prompt,
            authorId: spawnContext.owner.userId,
            source: "agent",
          }),
        },
        ctx
      )
    );
  } catch (enqueueError) {
    logger.error("Failed to enqueue initial prompt for child session", {
      event: "session.spawn_child_prompt_enqueue_failed",
      parent_id: parentId,
      child_id: childId,
      trace_id: ctx.trace_id,
      request_id: ctx.request_id,
      error: enqueueError instanceof Error ? enqueueError.message : String(enqueueError),
    });
    await sessionStore.updateStatus(childId, "failed");
    return error("Failed to enqueue child session prompt", 500);
  }

  if (!promptResponse.ok) {
    logger.error("Failed to enqueue initial prompt for child session", {
      event: "session.spawn_child_prompt_enqueue_failed",
      parent_id: parentId,
      child_id: childId,
      prompt_status: promptResponse.status,
      trace_id: ctx.trace_id,
      request_id: ctx.request_id,
    });
    await sessionStore.updateStatus(childId, "failed");
    return error("Failed to enqueue child session prompt", 500);
  }

  // Notify parent session so connected clients can refresh child list
  ctx.executionCtx?.waitUntil(
    parentStub
      .fetch(
        internalRequest(
          "http://internal/internal/child-session-update",
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              childSessionId: childId,
              status: "created",
              title: body.title,
            }),
          },
          ctx
        )
      )
      .catch((err) => {
        logger.error("session.notify_parent_spawn.failed", { error: err });
      })
  );

  return json({ sessionId: childId, status: "created" }, 201);
}

async function handleListChildren(
  _request: Request,
  env: Env,
  match: RegExpMatchArray,
  _ctx: RequestContext
): Promise<Response> {
  const parentId = match.groups?.id;
  if (!parentId) return error("Parent session ID required");

  const sessionStore = new SessionIndexStore(env.DB);
  const children = await sessionStore.listByParent(parentId);

  return json({ children });
}

async function handleGetChild(
  _request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const parentId = match.groups?.id;
  const childId = match.groups?.childId;
  if (!parentId || !childId) return error("Parent and child session IDs required");

  const sessionStore = new SessionIndexStore(env.DB);
  const isChild = await sessionStore.isChildOf(childId, parentId);
  if (!isChild) {
    return error("Child session not found", 404);
  }

  // Fetch child summary from child DO
  const childDoId = env.SESSION.idFromName(childId);
  const childStub = env.SESSION.get(childDoId);

  const response = await childStub.fetch(
    internalRequest("http://internal/internal/child-summary", undefined, ctx)
  );

  return response;
}

async function handleCancelChild(
  _request: Request,
  env: Env,
  match: RegExpMatchArray,
  ctx: RequestContext
): Promise<Response> {
  const parentId = match.groups?.id;
  const childId = match.groups?.childId;
  if (!parentId || !childId) return error("Parent and child session IDs required");

  const sessionStore = new SessionIndexStore(env.DB);
  const isChild = await sessionStore.isChildOf(childId, parentId);
  if (!isChild) {
    return error("Child session not found", 404);
  }

  // Cancel via child DO
  const childDoId = env.SESSION.idFromName(childId);
  const childStub = env.SESSION.get(childDoId);

  const response = await childStub.fetch(
    internalRequest("http://internal/internal/cancel", { method: "POST" }, ctx)
  );

  // Update D1 status if cancel succeeded
  if (response.ok) {
    await sessionStore.updateStatus(childId, "cancelled");
  }

  return response;
}
